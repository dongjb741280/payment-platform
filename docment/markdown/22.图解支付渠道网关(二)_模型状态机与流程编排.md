# 22.图解支付渠道网关(二)_模型状态机与流程编排

在《图解渠道⽹关（⼀）：不只是对接渠道的接⼝》那篇⽂章中，介绍了渠道⽹关的定位，常⻅渠

道类型，产品架构，系统架构等内容。

今天这篇⽂章中，主要讲清楚如何抽象定义渠道模型，各种单据模型，状态机设计，流程引擎，以

及如何定义⼀种简单好⽤好理解的流程脚本等。不过最重要的是给出⼀个示例：如何从这些繁复各

异的渠道中找出规律，做好抽象，以不变应万变。⾥⾯涉及的⼀些架构分析思想，对于提升通⽤架

构能⼒也是⾮常有益的。



## 1. 前⾔

外部渠道是⽀付系统的资⾦来源与出⼝，所有的⽀付系统都需要对接各种各样的外部渠道，⽐如银

⾏、第三⽅⽀付、外汇等，这些外部渠道形态各异，接⼝各异，流程也各不相同。

个⼈经历过好⼏种渠道接⼊的⽅式，最差也是最原始的⽅式，就是每来⼀个渠道就硬编码，各⾃if

else满天飞，各渠道间完全无法复用，接入成本高不说，维护成本也高得离谱。

今天，我们深⼊到渠道⽹关的核⼼——如何在多样化的⽀付渠道中找到共性，实现有效的抽象，以

应对不断变化的需求。这不仅是⽀付系统架构设计的挑战，也是提升通⽤架构能⼒的重要课题。



## 2. 分层 - 简单⽽有效的架构思想

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_2_img_1.png)

分层设计思想在软件架构设计中⽆处不在，已经到了⽇⽤⽽不⾃知的地步。在渠道⽹关的设计中，

也需要⽤到这个最基础的架构设计思想。

整个渠道⽹关，通常可以分成三层：业务层，流程编排层，接⼝对接层。

⾸先是业务层，负责处理上游的业务，对上游来说，渠道⽹关承担的核⼼业务就三个：

**流⼊：**通过渠道把⽤户的钱扣到平台的备付⾦账户。细分有：⽀付、预授权、请款、退款、撤销

等。

**流出：**通过渠道渠道把平台的备付⾦账户的钱给到⽤户，或者平台内部各账户进⾏调拨。细分有：

流出，退票。

**外汇：**查询汇率，再做货币兑换。

对于业务层来说，只需要把上游的请求收下来，再往下发流程引擎层，然后等待流程引擎处理结果

的推进。

接下来是流程引擎层。为什么要有流程引擎层？因为⼤部分渠道的流程是不⼀样的，⽐如有些渠

道，只需要请求渠道⼀次，就可以完成⽀付，但是有些渠道可能要请求3次才能完成⽀付：1）刷新

TOKEN；2）换取⽀付TOKEN）；3）发起真正的⽀付。⽽且还可能请求超时，这时需要查询补

单。这些操作如果和上面的业务层耦合在一起，将会变得非常复杂。

再往下，就是接⼝对接层，通常⼀个流⼊渠道有8到12个接⼝，⽐如签名，解约，⽀付，退款，⽀

付查询，退款查询，⽀付通知，退款通知，撤销，刷新TOKEN，换取TOKEN，清算⽂件等。不同

的渠道提供的接⼝不同，报⽂、签名签验、加密解密等也都不⼀样。

把上⾯分层思想完整实现出来，就是我们在《图解渠道⽹关：不只是对接渠道的接⼝（⼀）》那篇

⽂章中提到的系统架构图，如下：

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_3_img_1.png)

其中报⽂⽹关和⽂件⽹关就是渠道接⼝对接层的落地。



## 3. 领域模型

从上⾯“业务、流程编排、接⼝分离原则”导出的分层模型，我们可以看到，每层都是⾃⼰的领域

模型，但是需要有⼀根主线牵起来，那就是渠道模型。

所谓渠道模型就是我们对渠道能⼒的抽象，⽐如我们可以抽象为：⽹银、第三⽅钱包、卡、VA、

OTC等，也可抽象为代扣、快捷⽀付等，还需要把⽀付币种，限额，退款有效期等业务属性也抽象出来。

下⾯我们⼀个个说。



### 3.1. L0级别渠道⽹关领域模型

以流⼊（⽀付）渠道（通道）为例说明。流出、外汇的思路是差不多的。

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_4_img_1.png)



补充说明：

**渠道：**对外部的⽀付渠道（或者也叫⽀付通道）进⾏逻辑抽象，⽐如⽀付宝、微信⽀付、银联，国

外的WPG，MGPS等。

**渠道能⼒：**把外部渠道提供的基础能⼒进⼀步抽象出我们需要的能⼒，⽐如⽀付能⼒，退款能⼒

等。

**流程配置：**不同的渠道流程可能是不⼀样的，有些渠道⽀付只需要调⽤渠道⼀次，有些需要调⽤多

**接⼝：**渠道提供的原始接⼝能⼒。

**渠道视图：**我们对渠道配置了很多参数，但是有些参数对于渠道咨询或渠道决策不是必须的，所以

再抽象出⼀个渠道视图，⽤于渠道咨询或渠道决策。

**⽀付⽅式：**对⽤户可⻅的⽀付⽅式，可以做各种个性化的定义，和渠道视图没有⼀对⼀的映射关

系。

**业务单据：**⽐如⽀付、退款、请款等都是业务单据，依赖流程编排主单来推进状态。

**流程编排主单：**⽤于流程引擎的推进。每个业务单据需要对应⼀个流程编程编排主单。依赖渠道流

⽔单的状态来推进状态。

**渠道流⽔单：**每次和渠道交互，都⽣成⼀个独⽴的流⽔单，⽐如⼀笔⽀付，需要调⽤渠道的⽀付接

⼝，还可能有多次查询补单，也可能有渠道异步通知回来，每⼀次交互就会⽣成⼀笔流⽔单。多笔

渠道流⽔单对应⼀笔流程编排主单。



### 3.2. L1级别渠道模型

外部渠道定义或提供的能⼒各有差异，我们需要做渠道提供的基础能⼒做⼀个适配于我们内部业务

的抽象。

以⽀付渠道为例，可以抽象为：业务能⼒，资⾦能⼒，流程编排参数，接⼝能⼒等。业务能⼒包括

⽀付、退款、撤销等能⼒。⽀付能⼒⼜可以拆分为⽀付币种、限额、是否⽀持幂等，退款能⼒⼜可

以拆分为是否⽀持退款，退款有效期，退款限额等。

下面是一个经典的支付渠道抽象：

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_6_img_1.png)

---

说明：

渠道：对外部渠道做⼀个抽象，⽐如国内微信、⽀付宝、银联等，国外的WPG，MGPS等。

业务能⼒：⽀付、退款、撤销、请款等能⼒详细描述。⽐如退款有效期，最⼩限额等。

资⾦能⼒：清算币种等。

接⼝能⼒：描述接⼝本身的能⼒，⽐如渠道的请求号⽣成规则。特殊情况下可能有短号问题。

图中的渠道视图和⽀付⽅式在“L0级别渠道⽹关领域模型”章节中已经说明。



### 3.3. L1级别单据模型

因为使⽤了分层架构，上⾯的业务层只负责业务逻辑的推进，下⾯的流程引擎负责与渠道交互的流

程推进。所以单据也分为2种类型：业务单与流程编排单。

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_7_img_1.png)

---

业务单：⽐如⽀付、请款、退款、撤销等，是直接承载业务属性的，⽐如退款时要检查当前的可退

⾦额等。

流程编排单：只有主单和渠道交互流⽔单两种，承载流程编排。在流程编排单⾥⾯，不会做太多的

业务校验，只是按预先的脚本配置推进流程，第⼀步调⽤什么，第⼆步调⽤什么，根据结果码推进

状态等。在后⾯的“流程编排与流程引擎”有详细介绍。



## 4. 状态机

### 4.1. 业务单

⽀付：只有卡⽀付的预授权模式，才会有预授权成功和请款中状态。其它的⽀付没有这两个状态。

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_8_img_1.png)

---

退款：如果超过退款有效期，直接置为“退款失败”，所以有INIT直接到FAILED的情况。

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_9_img_1.png)

---

撤销单和退款单⽐较像，略。



### 4.2. 流程单

对于流程单来说，主单只有：初始，处理中，成功，失败，流⽔单则只有：未知、成功、失败。原

因在于流程单并不需要感知业务状态。

流程编排主单：初始，处理中，成功，失败。

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_10_img_1.png)

渠道交互流水单：未知，成功，失败。

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_11_img_1.png)

---



## 5. 流程编排与流程引擎

前⾯有说到，对于渠道交互来说，有些渠道的⽀付只需要⼀次交互，有些渠道的⽀付需要三次交

互，这些差异由流程编排层来吃掉。上层的业务层只负责业务状态的推进。

流程引擎有很多成熟的⽅案，⽽且很多都声称⾃⼰的是轻量级的，⽐如Activiti，JBMP，⼤家可

以根据⾃⼰的需要来选择。

不过对⽀付流程来说，仍然太重了，且⼤家都是做技术的，什么轮⼦都想⾃⼰造⼀个，对吧，我们

也不例外，经历过的⼏家公司都是⾃⼰造的⾃⼰的流程引擎轮⼦，哈哈。

先举个稍微复杂的例⼦：渠道需要3次交互（刷新token，获取paymentCode，最后⽀付），提供

查询和异步通知接口。主单和流水单的推进大概如下：

![图片1](./images/22.图解支付渠道网关(二)_模型状态机与流程编排_page_12_img_1.png)

---

图画得不太好，⼤家将就着看。

然后我们定义一种自己的语言来描述上面的流程，其实很简单，也很清晰，如下：

```java
public PayNeedRefreshTokenAndGetPaymentCodeFlow implements SimpleFlow {
/**
 * 支付流程，创建后，先
 推
 进到处理中，再刷新TOKEN，获取PAYMENTCODE，最后支付
 * 主单的状态为：INIT，PROCESS，SUCCESS，FAIL
 * 流水单的状态为：U，F，S
 */
@Override
public void config(FlowConfig config) {
// 创建后，通过事件CREATE推进到处理中
        config.sourceStatus(INIT).on(CREATE, PROCESS)
// 然后请求刷新TOKEN，如果失败，就推进流程主单到失败
        .request(refreshToken, subProcess().when(F).transTo(FAIL)
// 刷新成功，就获取支付码，如果失败，就推进流程主单到失败
        .when(S).request(getPaymentCode, subProcess().when(F).transTo
        (FAIL)
// 获取支付码成功，就支付
        when(S).request(pay, subProcess().when(S).transTo(SUCCES S).when(F).transTo(FAIL))));
// 支付回调通知
        config.sourceStatus(PROCESS).callback(payNotify, subProcess().when
        (S).transTo(SUCCESS).when(F).transTo(FAIL));
// 定时任务梯度查询补单
        config.suoreceStatus(PROCESS).query(payQuery, subProcess().when(S)
        .transTo(SUCCESS).when(F).transTo(FAIL));
        }
}
```

如果上面的比较复杂，我们看一下简单的普通支付，如下：

```java
public PayCommonFlow implements SimpleFlow{
/**
 * 支付流程，创建后，先
 * 推
 * 进到处理中，然后支付
 * 主单的状态为：INIT，PROCESS，SUCCESS，FAIL
 * 流水单的状态为：U，F，S
 */
@Override
public void config(FlowConfig config){
// 创建后，先
        推
        进到处理中
        config.sourceStatus(INIT).on(CREATE,PROCESS)
// 支付，如果失败，就推进流程主单到失败，如果成功，就推进主单到成功
        .request(pay,subProcess().when(S).transTo(SUCCESS).when(F).transT
        o(FAIL));
// 支付回调通知
        config.sourceStatus(PROCESS).callback(payNotify,subProcess().when
        (S).transTo(SUCCESS).when(F).transTo(FAIL));
// 定时任务梯度查询补单
        config.suoreceStatus(PROCESS).query(payQuery,subProcess().when(S)
        .transTo(SUCCESS).when(F).transTo(FAIL));
        }
        }
```

简单说明：

config.sourceStatus(STAUTS)：起始状态。

on(EVENT, STATUS)：通过事件推进到新的状态。

request(action, subProcess().when(status).transTo(STATUS)：请求动作，⽐如请求渠道⽀

付，再根据结果推进主单的状态。

callback(action, subProcess().when(status).transTo(STATUS)：回调动作，根据渠道异步通知

的结果推进主单的状态。

query(action, subProcess().when(status).transTo(STATUS)：查询动作，根据查询结果推进主

单的状态。

接下来就是，如何构建一个流程引擎，能解析并执行上面的脚本，只需要写几个类就可以了。

通过上⾯的分析，我们可以看到，和外部渠道（⽀付通道）再复杂的流程，只要分解⼀下，就很简

单，就那么⼏个步骤组合，然后写⼀个好理解的脚本，加⼏个类就可以处理得相当妥当，既不需要

引⼊Activiti那么复杂的流程引擎，也不⽤写⼀堆不好理解的XML配置⽂件。

再补充说⼀点，流⽔单怎么判断是推进到F（FIAL失败）还是S（SUCCESS成功），还是啥事不

⼲的U（UNKNOW未知）呢？很简单，就是通过渠道返回码的映射。明确渠道明确场景明确返回

码映射到指定的状态就⾏。这个很简单，就不废笔墨了。



## 6. 结束语

今天主要讲了如何抽象定义渠道模型，渠道⽹关内部核⼼的领域模型，状态机设计，流程引擎，⼀

种还不错的流程脚本定义等。

不过这些都是次要的，最重要的是我们要想办法探寻事物的本质是什么，再做适当的抽象，复杂的

事情要想办法往简单地做。

⽐如渠道千千万万，我们只需要抽象我们需要的能⼒，形成⾃⼰的渠道能⼒模型。渠道的交互千差

万别，我们只需要使⽤分层的架构思想，让各层各司其职，瞬间就简单了很多。当看到需要流程编

排时，也不⽤想着⽴⻢要引⼊各种流程引擎框架，或许加⼏个简单的类就可以搞定。

渠道⽹关的解构暂时先告⼀段落。后⾯有时间再补上报⽂⽹关、⽂件⽹关、渠道路由等这些核⼼部

件的解构。

