# 支付平台技术实现指南

## 1. 项目结构设计

### 1.1 微服务模块划分

```
payment-platform/
├── payment-gateway/          # 网关服务
├── payment-common/           # 公共组件
├── payment-account/          # 账户服务
├── payment-merchant/         # 商户服务
├── payment-user/            # 用户服务
├── payment-acquiring/       # 收单服务
├── payment-checkout/        # 收银台服务
├── payment-engine/          # 支付引擎
├── payment-channel/         # 渠道网关
├── payment-fund/            # 资金产品
├── payment-accounting/      # 账务服务
├── payment-risk/            # 风控服务
├── payment-key/             # 密钥服务
├── payment-reconciliation/  # 对账服务
├── payment-admin/           # 管理后台
└── payment-monitor/         # 监控服务
```

### 1.2 公共组件设计

#### 1.2.1 业务ID生成器
```java
@Component
public class BusinessIdGenerator {
    
    /**
     * 生成32位业务ID
     * 格式: YYYYMMDD + 版本位 + 系统位 + 业务位 + 机房位 + 分库位 + 分表位 + 环境位 + 序列号
     */
    public String generateBusinessId(BusinessIdRequest request) {
        // 实现业务ID生成逻辑
    }
}
```

#### 1.2.2 状态机框架
```java
public interface StateMachine<S extends BaseStatus, E extends BaseEvent> {
    S getTargetStatus(S sourceStatus, E event);
    void accept(S sourceStatus, E event, S targetStatus);
}

public abstract class BaseStateMachine<S extends BaseStatus, E extends BaseEvent> {
    protected final Map<StatusEventPair<S, E>, S> statusEventMap = new HashMap<>();
    
    public S getTargetStatus(S sourceStatus, E event) {
        return statusEventMap.get(new StatusEventPair<>(sourceStatus, event));
    }
    
    public void accept(S sourceStatus, E event, S targetStatus) {
        statusEventMap.put(new StatusEventPair<>(sourceStatus, event), targetStatus);
    }
}
```

#### 1.2.3 幂等性组件
```java
@Component
public class IdempotentService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private IdempotentMapper idempotentMapper;
    
    public boolean checkIdempotent(String uniqueKey, String appName) {
        // 1. 先查缓存
        String cacheKey = "idempotent:" + appName + ":" + uniqueKey;
        if (redisTemplate.hasKey(cacheKey)) {
            return true;
        }
        
        // 2. 查数据库
        IdempotentRecord record = idempotentMapper.selectByUniqueKey(uniqueKey);
        if (record != null) {
            // 刷新缓存
            redisTemplate.opsForValue().set(cacheKey, record, Duration.ofHours(24));
            return true;
        }
        
        return false;
    }
    
    public void saveIdempotent(String uniqueKey, String appName, Object extInfo) {
        // 保存幂等记录
        IdempotentRecord record = new IdempotentRecord();
        record.setUniqueKey(uniqueKey);
        record.setAppName(appName);
        record.setExtInfo(JSON.toJSONString(extInfo));
        record.setCreateTime(new Date());
        
        idempotentMapper.insert(record);
        
        // 刷新缓存
        String cacheKey = "idempotent:" + appName + ":" + uniqueKey;
        redisTemplate.opsForValue().set(cacheKey, record, Duration.ofHours(24));
    }
}
```

## 2. 核心业务实现

### 2.1 收单服务实现

#### 2.1.1 交易订单状态机
```java
public enum TradeOrderStatus implements BaseStatus {
    INIT("INIT", "初始化"),
    PAYING("PAYING", "支付中"),
    SUCCESS("SUCCESS", "支付成功"),
    FAILED("FAILED", "支付失败"),
    CLOSED("CLOSED", "订单关闭");
    
    private static final StateMachine<TradeOrderStatus, TradeOrderEvent> STATE_MACHINE = new StateMachine<>();
    
    static {
        STATE_MACHINE.accept(null, TradeOrderEvent.ORDER_CREATE, INIT);
        STATE_MACHINE.accept(INIT, TradeOrderEvent.PAY_START, PAYING);
        STATE_MACHINE.accept(PAYING, TradeOrderEvent.PAY_SUCCESS, SUCCESS);
        STATE_MACHINE.accept(PAYING, TradeOrderEvent.PAY_FAIL, FAILED);
        STATE_MACHINE.accept(INIT, TradeOrderEvent.ORDER_CLOSE, CLOSED);
        STATE_MACHINE.accept(PAYING, TradeOrderEvent.ORDER_CLOSE, CLOSED);
    }
    
    public static TradeOrderStatus getTargetStatus(TradeOrderStatus sourceStatus, TradeOrderEvent event) {
        return STATE_MACHINE.getTargetStatus(sourceStatus, event);
    }
}
```

#### 2.1.2 收单服务实现
```java
@Service
@Transactional
public class AcquiringServiceImpl implements AcquiringService {
    
    @Autowired
    private TradeOrderMapper tradeOrderMapper;
    
    @Autowired
    private IdempotentService idempotentService;
    
    @Autowired
    private PaymentEngineService paymentEngineService;
    
    public TradeOrderResponse createOrder(TradeOrderRequest request) {
        // 1. 幂等性检查
        String uniqueKey = request.getMerchantOrderNo() + "_" + request.getMerchantId();
        if (idempotentService.checkIdempotent(uniqueKey, "acquiring")) {
            throw new BusinessException("重复订单");
        }
        
        // 2. 创建交易订单
        TradeOrder order = new TradeOrder();
        order.setTradeOrderNo(businessIdGenerator.generateTradeOrderNo());
        order.setMerchantId(request.getMerchantId());
        order.setMerchantOrderNo(request.getMerchantOrderNo());
        order.setAmount(request.getAmount());
        order.setCurrency(request.getCurrency());
        order.setStatus(TradeOrderStatus.INIT);
        order.setCreateTime(new Date());
        
        tradeOrderMapper.insert(order);
        
        // 3. 保存幂等记录
        idempotentService.saveIdempotent(uniqueKey, "acquiring", order);
        
        // 4. 返回结果
        return TradeOrderResponse.builder()
                .tradeOrderNo(order.getTradeOrderNo())
                .status(order.getStatus())
                .build();
    }
    
    public PaymentResponse processPayment(PaymentRequest request) {
        // 1. 查询订单
        TradeOrder order = tradeOrderMapper.selectByTradeOrderNo(request.getTradeOrderNo());
        if (order == null) {
            throw new BusinessException("订单不存在");
        }
        
        // 2. 状态机推进
        try {
            order.transferStatusByEvent(TradeOrderEvent.PAY_START);
            tradeOrderMapper.updateByPrimaryKey(order);
        } catch (StateMachineException e) {
            throw new BusinessException("订单状态错误");
        }
        
        // 3. 调用支付引擎
        PaymentEngineRequest engineRequest = PaymentEngineRequest.builder()
                .tradeOrderNo(order.getTradeOrderNo())
                .amount(order.getAmount())
                .paymentMethod(request.getPaymentMethod())
                .build();
        
        PaymentEngineResponse engineResponse = paymentEngineService.processPayment(engineRequest);
        
        // 4. 更新订单状态
        if (engineResponse.isSuccess()) {
            order.transferStatusByEvent(TradeOrderEvent.PAY_SUCCESS);
        } else {
            order.transferStatusByEvent(TradeOrderEvent.PAY_FAIL);
        }
        tradeOrderMapper.updateByPrimaryKey(order);
        
        return PaymentResponse.builder()
                .success(engineResponse.isSuccess())
                .tradeOrderNo(order.getTradeOrderNo())
                .status(order.getStatus())
                .build();
    }
}
```

### 2.2 支付引擎实现

#### 2.2.1 支付引擎服务
```java
@Service
@Transactional
public class PaymentEngineServiceImpl implements PaymentEngineService {
    
    @Autowired
    private PaymentMainMapper paymentMainMapper;
    
    @Autowired
    private PaymentDetailMapper paymentDetailMapper;
    
    @Autowired
    private ChannelGatewayService channelGatewayService;
    
    @Autowired
    private AccountingService accountingService;
    
    public PaymentEngineResponse processPayment(PaymentEngineRequest request) {
        // 1. 创建支付主单
        PaymentMain paymentMain = createPaymentMain(request);
        
        // 2. 创建支付明细
        PaymentDetail paymentDetail = createPaymentDetail(request, paymentMain);
        
        // 3. 调用渠道网关
        ChannelPaymentRequest channelRequest = ChannelPaymentRequest.builder()
                .paymentDetailNo(paymentDetail.getPaymentDetailNo())
                .amount(request.getAmount())
                .paymentMethod(request.getPaymentMethod())
                .build();
        
        ChannelPaymentResponse channelResponse = channelGatewayService.processPayment(channelRequest);
        
        // 4. 更新支付状态
        if (channelResponse.isSuccess()) {
            paymentMain.transferStatusByEvent(PaymentEvent.PAY_SUCCESS);
            paymentDetail.transferStatusByEvent(PaymentEvent.PAY_SUCCESS);
            
            // 5. 记账
            accountingService.recordPayment(paymentMain, paymentDetail);
        } else {
            paymentMain.transferStatusByEvent(PaymentEvent.PAY_FAIL);
            paymentDetail.transferStatusByEvent(PaymentEvent.PAY_FAIL);
        }
        
        paymentMainMapper.updateByPrimaryKey(paymentMain);
        paymentDetailMapper.updateByPrimaryKey(paymentDetail);
        
        return PaymentEngineResponse.builder()
                .success(channelResponse.isSuccess())
                .paymentMainNo(paymentMain.getPaymentMainNo())
                .build();
    }
    
    private PaymentMain createPaymentMain(PaymentEngineRequest request) {
        PaymentMain paymentMain = new PaymentMain();
        paymentMain.setPaymentMainNo(businessIdGenerator.generatePaymentMainNo());
        paymentMain.setTradeOrderNo(request.getTradeOrderNo());
        paymentMain.setAmount(request.getAmount());
        paymentMain.setStatus(PaymentStatus.INIT);
        paymentMain.setCreateTime(new Date());
        
        paymentMainMapper.insert(paymentMain);
        return paymentMain;
    }
    
    private PaymentDetail createPaymentDetail(PaymentEngineRequest request, PaymentMain paymentMain) {
        PaymentDetail paymentDetail = new PaymentDetail();
        paymentDetail.setPaymentDetailNo(businessIdGenerator.generatePaymentDetailNo());
        paymentDetail.setPaymentMainNo(paymentMain.getPaymentMainNo());
        paymentDetail.setPaymentMethod(request.getPaymentMethod());
        paymentDetail.setAmount(request.getAmount());
        paymentDetail.setStatus(PaymentStatus.INIT);
        paymentDetail.setCreateTime(new Date());
        
        paymentDetailMapper.insert(paymentDetail);
        return paymentDetail;
    }
}
```

### 2.3 渠道网关实现

#### 2.3.1 渠道网关服务
```java
@Service
public class ChannelGatewayServiceImpl implements ChannelGatewayService {
    
    @Autowired
    private ChannelConfigService channelConfigService;
    
    @Autowired
    private ChannelRouterService channelRouterService;
    
    public ChannelPaymentResponse processPayment(ChannelPaymentRequest request) {
        // 1. 渠道路由
        ChannelConfig channelConfig = channelRouterService.routeChannel(request);
        
        // 2. 获取渠道处理器
        ChannelHandler channelHandler = channelHandlerFactory.getHandler(channelConfig.getChannelCode());
        
        // 3. 调用渠道
        ChannelPaymentResponse response = channelHandler.processPayment(request, channelConfig);
        
        // 4. 记录渠道调用日志
        recordChannelLog(request, response, channelConfig);
        
        return response;
    }
    
    private void recordChannelLog(ChannelPaymentRequest request, ChannelPaymentResponse response, ChannelConfig config) {
        ChannelLog log = new ChannelLog();
        log.setRequestId(UUID.randomUUID().toString());
        log.setChannelCode(config.getChannelCode());
        log.setRequestData(JSON.toJSONString(request));
        log.setResponseData(JSON.toJSONString(response));
        log.setCreateTime(new Date());
        
        channelLogMapper.insert(log);
    }
}
```

#### 2.3.2 渠道处理器接口
```java
public interface ChannelHandler {
    
    ChannelPaymentResponse processPayment(ChannelPaymentRequest request, ChannelConfig config);
    
    ChannelRefundResponse processRefund(ChannelRefundRequest request, ChannelConfig config);
    
    ChannelQueryResponse queryPayment(ChannelQueryRequest request, ChannelConfig config);
}
```

#### 2.3.3 支付宝渠道实现
```java
@Component("alipay")
public class AlipayChannelHandler implements ChannelHandler {
    
    @Autowired
    private AlipayClient alipayClient;
    
    @Override
    public ChannelPaymentResponse processPayment(ChannelPaymentRequest request, ChannelConfig config) {
        try {
            // 构建支付宝请求
            AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();
            alipayRequest.setReturnUrl(config.getReturnUrl());
            alipayRequest.setNotifyUrl(config.getNotifyUrl());
            
            AlipayTradePagePayModel model = new AlipayTradePagePayModel();
            model.setOutTradeNo(request.getPaymentDetailNo());
            model.setTotalAmount(request.getAmount().toString());
            model.setSubject("支付订单");
            model.setProductCode("FAST_INSTANT_TRADE_PAY");
            
            alipayRequest.setBizModel(model);
            
            // 调用支付宝接口
            AlipayTradePagePayResponse response = alipayClient.pageExecute(alipayRequest);
            
            return ChannelPaymentResponse.builder()
                    .success(response.isSuccess())
                    .channelOrderNo(response.getTradeNo())
                    .payUrl(response.getBody())
                    .build();
                    
        } catch (Exception e) {
            log.error("支付宝支付失败", e);
            return ChannelPaymentResponse.builder()
                    .success(false)
                    .errorCode("ALIPAY_ERROR")
                    .errorMessage(e.getMessage())
                    .build();
        }
    }
}
```

## 3. 安全实现

### 3.1 签名验签实现

#### 3.1.1 签名工具类
```java
@Component
public class SignatureUtil {
    
    /**
     * RSA签名
     */
    public String rsaSign(String data, String privateKey) {
        try {
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.decode(privateKey));
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PrivateKey priKey = keyFactory.generatePrivate(keySpec);
            
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(priKey);
            signature.update(data.getBytes("UTF-8"));
            
            return Base64.encode(signature.sign());
        } catch (Exception e) {
            throw new RuntimeException("签名失败", e);
        }
    }
    
    /**
     * RSA验签
     */
    public boolean rsaVerify(String data, String publicKey, String signature) {
        try {
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(Base64.decode(publicKey));
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PublicKey pubKey = keyFactory.generatePublic(keySpec);
            
            Signature sig = Signature.getInstance("SHA256withRSA");
            sig.initVerify(pubKey);
            sig.update(data.getBytes("UTF-8"));
            
            return sig.verify(Base64.decode(signature));
        } catch (Exception e) {
            log.error("验签失败", e);
            return false;
        }
    }
}
```

#### 3.1.2 签名拦截器
```java
@Component
public class SignatureInterceptor implements HandlerInterceptor {
    
    @Autowired
    private SignatureUtil signatureUtil;
    
    @Autowired
    private MerchantService merchantService;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 获取签名参数
        String signature = request.getHeader("X-Signature");
        String timestamp = request.getHeader("X-Timestamp");
        String nonce = request.getHeader("X-Nonce");
        String merchantId = request.getHeader("X-Merchant-Id");
        
        if (StringUtils.isAnyBlank(signature, timestamp, nonce, merchantId)) {
            throw new BusinessException("签名参数缺失");
        }
        
        // 时间戳校验
        long currentTime = System.currentTimeMillis();
        long requestTime = Long.parseLong(timestamp);
        if (Math.abs(currentTime - requestTime) > 300000) { // 5分钟
            throw new BusinessException("请求已过期");
        }
        
        // 获取商户公钥
        Merchant merchant = merchantService.getMerchant(merchantId);
        if (merchant == null) {
            throw new BusinessException("商户不存在");
        }
        
        // 构建签名字符串
        String signData = buildSignData(request, timestamp, nonce);
        
        // 验签
        if (!signatureUtil.rsaVerify(signData, merchant.getPublicKey(), signature)) {
            throw new BusinessException("签名验证失败");
        }
        
        return true;
    }
    
    private String buildSignData(HttpServletRequest request, String timestamp, String nonce) {
        // 构建待签名字符串
        StringBuilder sb = new StringBuilder();
        sb.append("method=").append(request.getMethod());
        sb.append("&uri=").append(request.getRequestURI());
        sb.append("&timestamp=").append(timestamp);
        sb.append("&nonce=").append(nonce);
        
        // 添加请求参数
        Map<String, String[]> parameterMap = request.getParameterMap();
        parameterMap.entrySet().stream()
                .sorted(Map.Entry.comparingByKey())
                .forEach(entry -> {
                    String value = String.join(",", entry.getValue());
                    sb.append("&").append(entry.getKey()).append("=").append(value);
                });
        
        return sb.toString();
    }
}
```

### 3.2 密钥管理实现

#### 3.2.1 密钥服务
```java
@Service
public class KeyManagementServiceImpl implements KeyManagementService {
    
    @Autowired
    private KeyConfigMapper keyConfigMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 获取工作密钥
     */
    public String getWorkingKey(String keyId) {
        String cacheKey = "working_key:" + keyId;
        
        // 先从缓存获取
        String key = (String) redisTemplate.opsForValue().get(cacheKey);
        if (key != null) {
            return key;
        }
        
        // 从数据库获取
        KeyConfig keyConfig = keyConfigMapper.selectByKeyId(keyId);
        if (keyConfig == null) {
            throw new BusinessException("密钥不存在");
        }
        
        // 解密工作密钥
        String workingKey = decryptWorkingKey(keyConfig.getEncryptedKey());
        
        // 缓存密钥
        redisTemplate.opsForValue().set(cacheKey, workingKey, Duration.ofHours(1));
        
        return workingKey;
    }
    
    /**
     * 加密数据
     */
    public String encrypt(String data, String keyId) {
        String workingKey = getWorkingKey(keyId);
        return AESUtil.encrypt(data, workingKey);
    }
    
    /**
     * 解密数据
     */
    public String decrypt(String encryptedData, String keyId) {
        String workingKey = getWorkingKey(keyId);
        return AESUtil.decrypt(encryptedData, workingKey);
    }
    
    private String decryptWorkingKey(String encryptedKey) {
        // 使用主密钥解密工作密钥
        // 这里需要调用HSM或硬件加密机
        return hsmService.decrypt(encryptedKey);
    }
}
```

## 4. 数据库设计

### 4.1 核心表结构

#### 4.1.1 交易订单表
```sql
CREATE TABLE t_trade_order (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    trade_order_no VARCHAR(32) NOT NULL UNIQUE COMMENT '交易订单号',
    merchant_id VARCHAR(32) NOT NULL COMMENT '商户ID',
    merchant_order_no VARCHAR(64) NOT NULL COMMENT '商户订单号',
    amount DECIMAL(15,2) NOT NULL COMMENT '订单金额',
    currency VARCHAR(3) NOT NULL DEFAULT 'CNY' COMMENT '币种',
    status VARCHAR(16) NOT NULL COMMENT '订单状态',
    create_time DATETIME NOT NULL COMMENT '创建时间',
    update_time DATETIME NOT NULL COMMENT '更新时间',
    INDEX idx_merchant_order (merchant_id, merchant_order_no),
    INDEX idx_create_time (create_time)
) COMMENT '交易订单表';
```

#### 4.1.2 支付主单表
```sql
CREATE TABLE t_payment_main (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    payment_main_no VARCHAR(32) NOT NULL UNIQUE COMMENT '支付主单号',
    trade_order_no VARCHAR(32) NOT NULL COMMENT '交易订单号',
    amount DECIMAL(15,2) NOT NULL COMMENT '支付金额',
    status VARCHAR(16) NOT NULL COMMENT '支付状态',
    create_time DATETIME NOT NULL COMMENT '创建时间',
    update_time DATETIME NOT NULL COMMENT '更新时间',
    INDEX idx_trade_order (trade_order_no),
    INDEX idx_create_time (create_time)
) COMMENT '支付主单表';
```

#### 4.1.3 账户表
```sql
CREATE TABLE t_account (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    account_no VARCHAR(32) NOT NULL UNIQUE COMMENT '账户号',
    account_type VARCHAR(16) NOT NULL COMMENT '账户类型',
    user_id VARCHAR(32) COMMENT '用户ID',
    merchant_id VARCHAR(32) COMMENT '商户ID',
    balance DECIMAL(15,2) NOT NULL DEFAULT 0 COMMENT '账户余额',
    frozen_amount DECIMAL(15,2) NOT NULL DEFAULT 0 COMMENT '冻结金额',
    status VARCHAR(16) NOT NULL DEFAULT 'ACTIVE' COMMENT '账户状态',
    create_time DATETIME NOT NULL COMMENT '创建时间',
    update_time DATETIME NOT NULL COMMENT '更新时间',
    INDEX idx_user_id (user_id),
    INDEX idx_merchant_id (merchant_id)
) COMMENT '账户表';
```

### 4.2 分库分表配置

#### 4.2.1 ShardingSphere配置
```yaml
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1,ds2,ds3
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/payment_db_0
        username: root
        password: password
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/payment_db_1
        username: root
        password: password
      ds2:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/payment_db_2
        username: root
        password: password
      ds3:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/payment_db_3
        username: root
        password: password
    
    sharding:
      tables:
        t_trade_order:
          actual-data-nodes: ds$->{0..3}.t_trade_order_$->{0..15}
          database-strategy:
            inline:
              sharding-column: merchant_id
              algorithm-expression: ds$->{merchant_id.hashCode() % 4}
          table-strategy:
            inline:
              sharding-column: create_time
              algorithm-expression: t_trade_order_$->{create_time.format('yyyyMM')}
```

## 5. 监控和运维

### 5.1 应用监控

#### 5.1.1 健康检查
```java
@Component
public class PaymentHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public Health health() {
        try {
            // 检查数据库连接
            checkDatabase();
            
            // 检查Redis连接
            checkRedis();
            
            return Health.up()
                    .withDetail("database", "UP")
                    .withDetail("redis", "UP")
                    .build();
        } catch (Exception e) {
            return Health.down()
                    .withDetail("error", e.getMessage())
                    .build();
        }
    }
    
    private void checkDatabase() throws SQLException {
        try (Connection connection = dataSource.getConnection()) {
            connection.createStatement().execute("SELECT 1");
        }
    }
    
    private void checkRedis() {
        redisTemplate.opsForValue().get("health_check");
    }
}
```

#### 5.1.2 业务指标监控
```java
@Component
public class PaymentMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public PaymentMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordPaymentSuccess(String channel) {
        Counter.builder("payment.success")
                .tag("channel", channel)
                .register(meterRegistry)
                .increment();
    }
    
    public void recordPaymentFailure(String channel, String errorCode) {
        Counter.builder("payment.failure")
                .tag("channel", channel)
                .tag("error_code", errorCode)
                .register(meterRegistry)
                .increment();
    }
    
    public void recordPaymentAmount(String channel, BigDecimal amount) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("payment.amount")
                .tag("channel", channel)
                .register(meterRegistry));
    }
}
```

### 5.2 日志配置

#### 5.2.1 Logback配置
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <springProfile name="!prod">
        <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        <root level="INFO">
            <appender-ref ref="STDOUT"/>
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>/var/log/payment/payment.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>/var/log/payment/payment.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
                <totalSizeCap>3GB</totalSizeCap>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        
        <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
            <appender-ref ref="FILE"/>
            <queueSize>1024</queueSize>
            <discardingThreshold>0</discardingThreshold>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="ASYNC"/>
        </root>
    </springProfile>
</configuration>
```

## 6. 部署配置

### 6.1 Docker配置

#### 6.1.1 Dockerfile
```dockerfile
FROM openjdk:17-jre-slim

VOLUME /tmp

COPY target/payment-service.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java","-jar","/app.jar"]
```

#### 6.1.2 Docker Compose
```yaml
version: '3.8'

services:
  payment-gateway:
    image: payment-gateway:latest
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - NACOS_SERVER_ADDR=nacos:8848
    depends_on:
      - nacos
      - mysql
      - redis

  payment-acquiring:
    image: payment-acquiring:latest
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - NACOS_SERVER_ADDR=nacos:8848
    depends_on:
      - nacos
      - mysql
      - redis

  nacos:
    image: nacos/nacos-server:v2.2.0
    ports:
      - "8848:8848"
    environment:
      - MODE=standalone

  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=payment_db
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mysql_data:
  redis_data:
```

### 6.2 Kubernetes配置

#### 6.2.1 Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: payment-gateway
  template:
    metadata:
      labels:
        app: payment-gateway
    spec:
      containers:
      - name: payment-gateway
        image: payment-gateway:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: NACOS_SERVER_ADDR
          value: "nacos-service:8848"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
```

#### 6.2.2 Service
```yaml
apiVersion: v1
kind: Service
metadata:
  name: payment-gateway-service
spec:
  selector:
    app: payment-gateway
  ports:
  - port: 8080
    targetPort: 8080
  type: LoadBalancer
```

## 7. 测试策略

### 7.1 单元测试

#### 7.1.1 服务层测试
```java
@ExtendWith(MockitoExtension.class)
class AcquiringServiceImplTest {
    
    @Mock
    private TradeOrderMapper tradeOrderMapper;
    
    @Mock
    private IdempotentService idempotentService;
    
    @InjectMocks
    private AcquiringServiceImpl acquiringService;
    
    @Test
    void testCreateOrder_Success() {
        // Given
        TradeOrderRequest request = TradeOrderRequest.builder()
                .merchantId("M001")
                .merchantOrderNo("ORDER001")
                .amount(new BigDecimal("100.00"))
                .build();
        
        when(idempotentService.checkIdempotent(anyString(), anyString())).thenReturn(false);
        when(tradeOrderMapper.insert(any(TradeOrder.class))).thenReturn(1);
        
        // When
        TradeOrderResponse response = acquiringService.createOrder(request);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getStatus()).isEqualTo(TradeOrderStatus.INIT);
        verify(tradeOrderMapper).insert(any(TradeOrder.class));
    }
    
    @Test
    void testCreateOrder_DuplicateOrder() {
        // Given
        TradeOrderRequest request = TradeOrderRequest.builder()
                .merchantId("M001")
                .merchantOrderNo("ORDER001")
                .amount(new BigDecimal("100.00"))
                .build();
        
        when(idempotentService.checkIdempotent(anyString(), anyString())).thenReturn(true);
        
        // When & Then
        assertThatThrownBy(() -> acquiringService.createOrder(request))
                .isInstanceOf(BusinessException.class)
                .hasMessage("重复订单");
    }
}
```

### 7.2 集成测试

#### 7.2.1 支付流程测试
```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class PaymentFlowIntegrationTest {
    
    @Autowired
    private AcquiringService acquiringService;
    
    @Autowired
    private PaymentEngineService paymentEngineService;
    
    @Test
    @Transactional
    void testCompletePaymentFlow() {
        // 1. 创建订单
        TradeOrderRequest orderRequest = TradeOrderRequest.builder()
                .merchantId("M001")
                .merchantOrderNo("ORDER001")
                .amount(new BigDecimal("100.00"))
                .build();
        
        TradeOrderResponse orderResponse = acquiringService.createOrder(orderRequest);
        assertThat(orderResponse.getStatus()).isEqualTo(TradeOrderStatus.INIT);
        
        // 2. 发起支付
        PaymentRequest paymentRequest = PaymentRequest.builder()
                .tradeOrderNo(orderResponse.getTradeOrderNo())
                .paymentMethod("ALIPAY")
                .build();
        
        PaymentResponse paymentResponse = acquiringService.processPayment(paymentRequest);
        assertThat(paymentResponse.isSuccess()).isTrue();
    }
}
```

## 8. 性能优化

### 8.1 数据库优化

#### 8.1.1 索引优化
```sql
-- 为高频查询字段添加索引
CREATE INDEX idx_trade_order_merchant_time ON t_trade_order(merchant_id, create_time);
CREATE INDEX idx_payment_main_trade_order ON t_payment_main(trade_order_no);
CREATE INDEX idx_account_user_id ON t_account(user_id);

-- 复合索引优化
CREATE INDEX idx_trade_order_status_time ON t_trade_order(status, create_time);
```

#### 8.1.2 查询优化
```java
@Repository
public class TradeOrderRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * 分页查询优化
     */
    public Page<TradeOrder> findOrdersByMerchant(String merchantId, Pageable pageable) {
        String sql = "SELECT * FROM t_trade_order WHERE merchant_id = ? ORDER BY create_time DESC LIMIT ?, ?";
        
        List<TradeOrder> orders = jdbcTemplate.query(sql, 
            new Object[]{merchantId, pageable.getOffset(), pageable.getPageSize()},
            new TradeOrderRowMapper());
        
        String countSql = "SELECT COUNT(*) FROM t_trade_order WHERE merchant_id = ?";
        Long total = jdbcTemplate.queryForObject(countSql, Long.class, merchantId);
        
        return new PageImpl<>(orders, pageable, total);
    }
}
```

### 8.2 缓存优化

#### 8.2.1 Redis缓存策略
```java
@Service
public class CacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 多级缓存策略
     */
    @Cacheable(value = "merchant", key = "#merchantId", unless = "#result == null")
    public Merchant getMerchant(String merchantId) {
        // 先从本地缓存获取
        Merchant merchant = localCache.get(merchantId);
        if (merchant != null) {
            return merchant;
        }
        
        // 从Redis获取
        merchant = (Merchant) redisTemplate.opsForValue().get("merchant:" + merchantId);
        if (merchant != null) {
            localCache.put(merchantId, merchant);
            return merchant;
        }
        
        // 从数据库获取
        merchant = merchantMapper.selectByMerchantId(merchantId);
        if (merchant != null) {
            redisTemplate.opsForValue().set("merchant:" + merchantId, merchant, Duration.ofHours(1));
            localCache.put(merchantId, merchant);
        }
        
        return merchant;
    }
}
```

## 9. 总结

本技术实现指南提供了支付平台的核心技术实现方案，包括：

1. **项目结构设计**: 微服务模块划分和公共组件设计
2. **核心业务实现**: 收单、支付引擎、渠道网关等核心服务
3. **安全实现**: 签名验签、密钥管理等安全机制
4. **数据库设计**: 表结构设计和分库分表策略
5. **监控运维**: 应用监控、日志配置等运维方案
6. **部署配置**: Docker和Kubernetes部署方案
7. **测试策略**: 单元测试和集成测试方案
8. **性能优化**: 数据库和缓存优化策略

通过本指南的实施，可以构建一个安全、高效、可扩展的现代化支付平台，满足企业级支付业务的需求。
